import * as tf from '@tensorflow/tfjs';
import fs from 'fs';
import readline from 'readline';
import { exec } from 'child_process';

import chalk from 'chalk';
import figlet from 'figlet';
import gradient from 'gradient-string';
import boxen from 'boxen';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);


const MODEL_FILE = 'model.json';
const WEIGHTS_FILE = 'weights.bin';
const NORMALIZATION_FILE = 'normalization.json';
const REINFORCEMENT_FILE = 'reinforcement.json';
const BACKUP_FILE = "reinforcement.json.backup";
const TEMP_FILE = "reinforcement.json.tmp";
import path from 'path';
import os from 'os';
const HELP_FILE = 'help.txt';
const LEARNING_RATE = 0.01;
const EPOCHS = 100;
const DISCOUNT_FACTOR = 0.95;
const EPSILON = 0.1;
const REPLAY_BUFFER_SIZE = 100;
const command = process.argv[2];
import { spawn } from "child_process";
// ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ createCanvas ŸÖŸÜ ŸÖŸÉÿ™ÿ®ÿ© 'canvas' ŸÑÿ•ŸÜÿ¥ÿßÿ° Ÿàÿ±ÿ≥ŸÖ ÿßŸÑÿ±ÿ≥ŸàŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸäÿ© ÿ®ÿØŸàŸÜ ÿßŸÑÿ≠ÿßÿ¨ÿ© ÿ•ŸÑŸâ ŸÖÿ≥ÿ™ÿπÿ±ÿ∂
import { createCanvas } from 'canvas';

// ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ŸÖŸÉÿ™ÿ®ÿ© Chart.js ŸÑÿ±ÿ≥ŸÖ ÿßŸÑÿ±ÿ≥ŸàŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸäÿ© ÿ®ÿ≥ŸáŸàŸÑÿ©
import Chart from 'chart.js/auto';

// ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ŸÖŸÉÿ™ÿ®ÿ© 'xlsx' ŸÑŸÑÿ™ÿπÿßŸÖŸÑ ŸÖÿπ ŸÖŸÑŸÅÿßÿ™ Excel ÿ®ÿµŸäÿ∫ÿ© XLSX (ŸÇÿ±ÿßÿ°ÿ© ŸàŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™)
import * as XLSX from 'xlsx';
import xlsx from 'xlsx';



// ÿ™ÿ≠ÿØŸäÿØ ŸÖÿ≥ÿßÿ± ÿ≠ŸÅÿ∏ ÿßŸÑÿ±ÿ≥ŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸä ÿßŸÑŸÖŸèŸÜÿ¥ÿ£
const CHART_PATH = './price_chart.png';

// ÿ™ÿ≠ÿØŸäÿØ ŸÖÿ≥ÿßÿ± ŸÖŸÑŸÅ Excel ÿßŸÑÿ∞Ÿä Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿßŸÑÿπŸÖŸÑŸäÿßÿ™ ÿ£Ÿà ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿÆÿ≤ŸÜÿ©
const EXCEL_PATH = './operations.xlsx';




// Ÿàÿ∏ŸäŸÅÿ© ŸÑÿπÿ±ÿ∂ ŸÖŸÑŸÅ ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©
function openHelpFile() {
    spawn("cmd", ["/c", "start", HELP_FILE], { detached: true, stdio: "ignore" }).unref();
    process.exit(0); // ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ŸÖÿ®ÿßÿ¥ÿ±ÿ© ÿ®ÿπÿØ ŸÅÿ™ÿ≠ ÿßŸÑŸÖŸÑŸÅ
}

if (command === "help") {
    openHelpFile();
}



// Function to reset all files
function resetFiles() {
    const files = [REINFORCEMENT_FILE, WEIGHTS_FILE, MODEL_FILE, NORMALIZATION_FILE];

    files.forEach(file => {
        if (fs.existsSync(file)) {
            fs.unlinkSync(file);
            console.log(`‚úÖ Deleted: ${file}`);
        } else {
            console.log(`‚ö†Ô∏è Not found: ${file}`);
        }
    });

    console.log("üöÄ All files have been reset.");
}

// Check if the script was run with "reset" argument
if (process.argv[2] === 'reset') {
    resetFiles();
    process.exit(); // Exit after resetting files
}


// Function to save and download the backup file
function saveBackup() {
    if (!fs.existsSync(BACKUP_FILE)) {
        console.log("‚ùå Backup file not found!");
        return;
    }

    // Get the user's Downloads folder
    const downloadsFolder = path.join(os.homedir(), 'Downloads');
    const destinationPath = path.join(downloadsFolder, BACKUP_FILE);

    // Copy the backup file to Downloads
    fs.copyFileSync(BACKUP_FILE, destinationPath);
    console.log(`‚úÖ Backup file saved to: ${destinationPath}`);
}

// Check command-line arguments

if (command === 'reset') {
    resetFiles();
    process.exit();
} else if (command === 'save') {
    saveBackup();
    process.exit();
}





// ‚úÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ Ÿàÿ∂ŸÖÿßŸÜ ÿ£ŸÜŸáÿß ŸÖÿµŸÅŸàŸÅÿ©
let replayBuffer = [];

try {
    if (fs.existsSync(REINFORCEMENT_FILE)) {
        const data = fs.readFileSync(REINFORCEMENT_FILE, 'utf-8').trim();
        const parsedData = data ? JSON.parse(data) : [];

        // üîπ If the data is an array, assign it; otherwise, keep the existing data
        if (Array.isArray(parsedData)) {
            replayBuffer = parsedData;
        } else {
            console.warn("‚ö†Ô∏è Warning: The replay file contains invalid data. Keeping the current buffer.");
        }
    } else {
        console.warn("‚ö†Ô∏è Warning: The replay file does not exist. Continuing with the current buffer.");
    }
} catch (error) {
    console.error("‚ùå Error: Unable to read the replay file.", error);
    console.warn("‚ö†Ô∏è Continuing with the existing buffer in memory.");
}


// ‚úÖ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÖÿß ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨ ŸÖŸàÿ¨ŸàÿØŸãÿß
function modelExists() {
    const files = [MODEL_FILE, WEIGHTS_FILE, NORMALIZATION_FILE, REINFORCEMENT_FILE];

    for (let file of files) {
        if (!fs.existsSync(file) || fs.statSync(file).size === 0) {
            return false;
        }
    }
    return true;
}

// ‚úÖ Ÿàÿ∏ŸäŸÅÿ© ŸÑÿ≠ŸÅÿ∏ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™ÿπŸÑŸäŸÖ ÿßŸÑŸÖÿπÿ≤ÿ≤ ÿ®ÿπÿØ ŸÉŸÑ ÿ™ÿ≠ÿØŸäÿ´
function storeExperience(state, actualCost) {
    if (state == null || actualCost == null) {
        console.warn("‚ö†Ô∏è Warning: Invalid experience data received.");
        return;
    }

    // üîπ ÿ™ÿ£ŸÉŸäÿØ ÿ£ŸÜ replayBuffer ŸÖÿµŸÅŸàŸÅÿ©
    if (!Array.isArray(replayBuffer)) {
        console.warn("‚ö†Ô∏è replayBuffer was not an array. Resetting...");
        replayBuffer = [];
    }

    replayBuffer.push({ state, actualCost });

    if (replayBuffer.length > REPLAY_BUFFER_SIZE) {
        replayBuffer.splice(0, 1);
    }

    try {
        fs.writeFileSync(REINFORCEMENT_FILE, JSON.stringify(replayBuffer, null, 2));
        console.log(`üì¶ Data stored successfully. Current size: ${replayBuffer.length}`);
    } catch (error) {
        console.error("‚ùå Error saving reinforcement learning data:", error);
    }
    
}



function createModel() {
    const model = tf.sequential();
    model.add(tf.layers.dense({ units: 64, activation: 'relu', inputShape: [8] }));
    model.add(tf.layers.dense({ units: 32, activation: 'relu' }));
    model.add(tf.layers.dense({ units: 1 }));
    model.compile({ optimizer: tf.train.adam(LEARNING_RATE), loss: 'meanSquaredError' });
    return model;
}




async function saveModel(model, normalizationParams, reinforcementData) {
    await model.save(tf.io.withSaveHandler(async (artifacts) => {
        fs.writeFileSync(MODEL_FILE, JSON.stringify({
            modelTopology: artifacts.modelTopology,
            weightSpecs: artifacts.weightSpecs
        }));
        fs.writeFileSync(WEIGHTS_FILE, Buffer.from(artifacts.weightData));
        fs.writeFileSync(NORMALIZATION_FILE, JSON.stringify(normalizationParams, null, 2));

        // Protect Replay Buffer data
        const TEMP_FILE = `${REINFORCEMENT_FILE}.tmp`;
        const BACKUP_FILE = `${REINFORCEMENT_FILE}.backup`;

        try {
            if (!Array.isArray(reinforcementData)) {
                console.warn("‚ö†Ô∏è Invalid reinforcement data! Skipping save.");
                return;
            }

            let existingData = [];

            // Load existing reinforcement data if available
            if (fs.existsSync(REINFORCEMENT_FILE)) {
                try {
                    const fileContent = fs.readFileSync(REINFORCEMENT_FILE, 'utf-8').trim();
                    if (fileContent.length > 0) {
                        existingData = JSON.parse(fileContent);
                        if (!Array.isArray(existingData)) {
                            console.warn("‚ö†Ô∏è Existing reinforcement file is not an array. Resetting...");
                            existingData = [];
                        }
                    }
                } catch (e) {
                    console.error("‚ùå Error reading existing reinforcement data:", e);
                    existingData = [];
                }
            }

            // Append new data to the existing array
            const updatedData = existingData.concat(reinforcementData);

            // Create a backup only if the file contains valid data
            if (existingData.length > 0) {
                fs.copyFileSync(REINFORCEMENT_FILE, BACKUP_FILE);
            }

            // Write to a temporary file first
            fs.writeFileSync(TEMP_FILE, JSON.stringify(updatedData, null, 2));

            // Replace the original file only after successful writing
            fs.renameSync(TEMP_FILE, REINFORCEMENT_FILE);

            // Validate record count after saving
            let savedData = [];
            let backupData = [];

            try {
                savedData = JSON.parse(fs.readFileSync(REINFORCEMENT_FILE, 'utf-8'));
            } catch (e) {
                console.error("‚ùå Failed to read saved data:", e);
            }

            if (fs.existsSync(BACKUP_FILE)) {
                try {
                    backupData = JSON.parse(fs.readFileSync(BACKUP_FILE, 'utf-8'));
                } catch (e) {
                    console.error("‚ùå Failed to read backup data:", e);
                }
            } else {
                console.warn("‚ö†Ô∏è Backup file not found, cannot validate record count.");
            }

            console.log(`üìä Records in backup: ${backupData.length}`);

            // Restore backup only if it contains valid data
            if (backupData.length > 0 && savedData.length !== backupData.length) {
                console.warn("‚ö†Ô∏è Record count mismatch detected. Restoring from backup...");
                fs.copyFileSync(BACKUP_FILE, REINFORCEMENT_FILE);
                console.log("‚úÖ Reinforcement file restored from backup.");
            }

            console.log("‚úÖ Model, reinforcement learning data & normalization parameters saved successfully!");

// Stop execution after success
process.exit(0);

        } catch (error) {
            console.error("‚ùå Error saving reinforcement data:", error);

            // Restore data only if the backup file is valid
            if (fs.existsSync(BACKUP_FILE)) {
                const backupContent = fs.readFileSync(BACKUP_FILE, 'utf-8').trim();
                if (backupContent.length > 0) {
                    fs.copyFileSync(BACKUP_FILE, REINFORCEMENT_FILE);
                    console.warn("‚ö†Ô∏è Data restored from backup due to an error.");
                } else {
                    console.warn("‚ö†Ô∏è Backup not restored because it is empty.");
                }
            }
// Exit with failure code after handling the error
process.exit(1);


        }
    }));
}




async function loadModel() {
    console.log("üìÇ Loading saved model...");

    try {
        // ‚úÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨
        if (!fs.existsSync(MODEL_FILE) || !fs.existsSync(WEIGHTS_FILE)) {
            throw new Error("‚ùå Model files not found!");
        }

        const modelData = JSON.parse(fs.readFileSync(MODEL_FILE, 'utf8'));
        const weightData = fs.readFileSync(WEIGHTS_FILE);
        const modelArtifacts = {
            modelTopology: modelData.modelTopology,
            weightSpecs: modelData.weightSpecs,
            weightData: new Uint8Array(weightData).buffer
        };

        // ‚úÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™ÿ∑ÿ®Ÿäÿπ
        if (!fs.existsSync(NORMALIZATION_FILE)) {
            throw new Error("‚ùå Normalization file not found!");
        }
        const normalizationParams = JSON.parse(fs.readFileSync(NORMALIZATION_FILE, 'utf8'));

        // ‚úÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™ÿπŸÑŸäŸÖ ÿßŸÑÿ™ÿπÿ≤Ÿäÿ≤Ÿä ÿ•ŸÜ Ÿàÿ¨ÿØ
        let reinforcementData = {}; 
        if (fs.existsSync(REINFORCEMENT_FILE)) {
            reinforcementData = JSON.parse(fs.readFileSync(REINFORCEMENT_FILE, 'utf8'));
            console.log("üìú Reinforcement Learning Data Loaded");
        } else {
            console.warn("‚ö†Ô∏è Reinforcement learning file not found!");
        }

        // ‚úÖ ÿßŸÑŸÇŸäŸÖ ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ© ŸÑÿß ÿ™ŸèŸÉÿ™ÿ® ŸÅŸä ÿßŸÑŸÖŸÑŸÅÿå ÿ™Ÿèÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸÇÿ∑ ÿπŸÜÿØ ÿßŸÑÿ≠ÿßÿ¨ÿ©
        const defaultReinforcement = {
            learningRate: 0.01,
            discountFactor: 0.99,
            explorationRate: 0.1
        };

        // ‚úÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÇŸäŸÖ ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ© ÿπŸÜÿØ ÿßŸÑÿ≠ÿßÿ¨ÿ© **ÿØŸàŸÜ ÿ™ÿπÿØŸäŸÑ ÿßŸÑŸÖŸÑŸÅ**
        const finalReinforcementData = {
            learningRate: reinforcementData.learningRate ?? defaultReinforcement.learningRate,
            discountFactor: reinforcementData.discountFactor ?? defaultReinforcement.discountFactor,
            explorationRate: reinforcementData.explorationRate ?? defaultReinforcement.explorationRate
        };

        // ‚úÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨ ŸÅŸä TensorFlow.js
        const model = await tf.loadLayersModel(tf.io.fromMemory(modelArtifacts));

        // ‚úÖ **ÿ•ÿπÿßÿØÿ© ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨ ÿ®ÿπÿØ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ ŸÑÿ≠ŸÑ ÿßŸÑŸÖÿ¥ŸÉŸÑÿ©**
        model.compile({
            optimizer: tf.train.adam(),
            loss: 'meanSquaredError',
            metrics: ['mse']
        });

        console.log("‚úÖ Model loaded and compiled successfully!");
        return { model, normalizationParams, reinforcementData: finalReinforcementData };

    } catch (error) {
        console.error("‚ö†Ô∏è Error loading model:", error.message);
        return null;
    }
}



function normalizeData(data, min, max) {
    if (!Array.isArray(data) || data.some(isNaN)) {
        throw new Error("‚ùå The input data must be an array of numbers!");
    }

    return data.map((value, index) => {
        if (value < min[index]) {
            console.warn(`‚ö†Ô∏è Warning: Value at index ${index} is below the minimum (${value} < ${min[index]}). It will be set to the minimum.`);
            value = min[index];
        } else if (value > max[index]) {
            console.warn(`‚ö†Ô∏è Warning: Value at index ${index} exceeds the maximum (${value} > ${max[index]}). It will be set to the maximum.`);
            value = max[index];
        }

        return (value - min[index]) / (max[index] - min[index]);
    });
}






async function trainModel(model) {
    console.log("üèóÔ∏è Training the model with reinforcement learning...");

    // ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖŸÜ Replay Buffer
    let replayBuffer = [];
    try {
        const bufferData = fs.readFileSync(REINFORCEMENT_FILE, "utf-8");
        replayBuffer = JSON.parse(bufferData);
    } catch (error) {
        console.warn("‚ö†Ô∏è No data in Replay Buffer, default data will be used.");
    }

    // ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™ÿØÿ±Ÿäÿ® ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©
    let rawXs = [
        [500, 1, 3, 5, 20, 1, 100, 2022],
        [1000, 2, 5, 10, 50, 2, 150, 2021],
        [700, 1, 4, 7, 30, 3, 120, 2023],
        [1200, 3, 6, 12, 60, 1, 200, 2020]
    ];

    let rawYs = [[50000], [120000], [70000], [150000]];

    replayBuffer.forEach(data => {
        if (data.state.length === 8) { // ÿ™ÿ£ŸÉÿØ ÿ£ŸÜ ÿßŸÑÿ•ÿØÿÆÿßŸÑ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ 8 ŸÇŸäŸÖ
            rawXs.push(data.state);
            rawYs.push([data.actualCost]); // ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÇŸäŸÖÿ© ÿ•ŸÑŸâ ŸÖÿµŸÅŸàŸÅÿ©
        } else {
            console.error("‚ùå ÿÆÿ∑ÿ£: ÿ®ŸäÿßŸÜÿßÿ™ Replay Buffer ÿ∫Ÿäÿ± ŸÖÿ™ŸàÿßŸÅŸÇÿ©", data);
        }
    });
    


// ‚úÖ ÿ∑ÿ®ÿßÿπÿ© ÿ®ŸäÿßŸÜÿßÿ™ rawXs Ÿà rawYs ŸÑŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑŸÇŸäŸÖ ŸÇÿ®ŸÑ ÿßŸÑÿ™ÿØÿ±Ÿäÿ®
console.log("rawXs:", rawXs);
console.log("rawYs:", rawYs);

    console.log(`üìä Training data used: ${rawXs.length} records`);



    // üìå ÿ≠ÿ≥ÿßÿ® min Ÿà max ŸÑŸÉŸÑ ÿπŸÖŸàÿØ ŸÅŸä rawXs
    const minInput = rawXs[0].map((_, colIndex) => Math.min(...rawXs.map(row => row[colIndex])));
    const maxInput = rawXs[0].map((_, colIndex) => Math.max(...rawXs.map(row => row[colIndex])));

    // üìå ÿ≠ÿ≥ÿßÿ® min Ÿà max ŸÑŸÄ rawYs
    const minOutput = Math.min(...rawYs.flat());
    const maxOutput = Math.max(...rawYs.flat());

    // üìå ÿ™ÿ∑ÿ®Ÿäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    const normalizedXs = rawXs.map(row => row.map((value, colIndex) => {
        const diff = maxInput[colIndex] - minInput[colIndex] || 1e-8;
        return (value - minInput[colIndex]) / diff;
    }));

    const normalizedYs = rawYs.map(row => row.map(value => {
        const diff = maxOutput - minOutput || 1e-8;
        return (value - minOutput) / diff;
    }));

    // üìå ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ•ŸÑŸâ Tensors
    const xs = tf.tensor2d(normalizedXs);
    const ys = tf.tensor2d(normalizedYs);

    try {
        console.log("üöÄ Training started...");
        await model.fit(xs, ys, { 
            epochs: EPOCHS, 
            batchSize: 32 // ŸäŸÖŸÉŸÜŸÉ ÿ™ÿ¨ÿ±ÿ®ÿ© ŸÇŸäŸÖ ÿ£ÿÆÿ±Ÿâ ŸÖÿ´ŸÑ 16ÿå 64ÿå ÿ≠ÿ≥ÿ® ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©
        });
        
        console.log("‚úÖ Training completed!");
    } catch (error) {
        console.error("‚ùå Error during training:", error);
        return null;
    }

    // üìå ÿ≠ŸÅÿ∏ ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨ ŸàŸÇŸäŸÖ ÿßŸÑÿ™ÿ∑ÿ®Ÿäÿπ
    const normalizationParams = { minInput, maxInput, minOutput, maxOutput };

    // ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ŸÅŸÇÿ∑ ÿßŸÑÿ•ÿØÿÆÿßŸÑÿßÿ™ ÿßŸÑÿ¨ÿØŸäÿØÿ© ŸÖŸÜ Replay Buffer
const reinforcementData = replayBuffer.map(data => ({
    state: data.state,
    actualCost: data.actualCost
}));

// ÿ≠ŸÅÿ∏ ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ•ÿØÿÆÿßŸÑÿßÿ™ ÿßŸÑÿ¨ÿØŸäÿØÿ© ŸÅŸÇÿ∑
await saveModel(model, normalizationParams, reinforcementData);


    return normalizationParams;
}




async function reinforcementLearning(model, userInput, actualCost, normalizationParams) {
    if (!model || !userInput || actualCost == null || !normalizationParams) {
        console.warn("‚ö†Ô∏è Warning: Invalid input to reinforcementLearning.");
        return;
    }

    if (Math.random() < EPSILON) return;

    // üìå ÿ≠ÿ≥ÿßÿ® `newState` ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ•ÿØÿÆÿßŸÑ
    const newState = [...userInput]; // ŸÅŸÇÿ∑ ŸÖÿØÿÆŸÑÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ®ÿØŸàŸÜ `actualCost`
    storeExperience(newState, actualCost);

    await trainModel(model);

    console.log(`üì¶ Buffer size: ${replayBuffer.length}`);

    if (replayBuffer.length < 10) return;

    // üìå ÿ£ÿÆÿ∞ ÿ¢ÿÆÿ± 50 ÿ™ÿ¨ÿ±ÿ®ÿ© ÿ£Ÿà ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ•ŸÜ ŸÉÿßŸÜÿ™ ÿ£ŸÇŸÑ ŸÖŸÜ 50
    const batch = replayBuffer.slice(-Math.min(50, replayBuffer.length));

    for (const { state, actualCost } of batch) {
        let inputTensor, actualTensor;

        // üìå ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿØÿßÿÆŸÑ `tf.tidy()`
        const tensors = tf.tidy(() => {
            const normalizedInput = normalizeData(state, normalizationParams.minInput, normalizationParams.maxInput);
            inputTensor = tf.tensor2d([normalizedInput]);
            const predictedTensor = model.predict(inputTensor);
            const predictedCost = predictedTensor.dataSync()[0];

            const reward = -Math.abs(actualCost - predictedCost);
            const targetCost = actualCost + DISCOUNT_FACTOR * reward;
            actualTensor = tf.tensor2d([[targetCost]]);

            return { inputTensor, actualTensor };
        });

        // ‚úÖ ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨ ŸÇÿ®ŸÑ ÿßŸÑÿ™ÿØÿ±Ÿäÿ®
        if (!model.optimizer) {
            console.log("üîÑ Compiling model before training...");
            model.compile({
                optimizer: 'adam',
                loss: 'meanSquaredError'
            });
        }

        try {
            console.log("üéØ Training model...");
            await model.fit(tensors.inputTensor, tensors.actualTensor, { epochs: 50, batchSize: 5 });
            console.log("üß† Model trained!");

            await saveModel(model, normalizationParams, replayBuffer);
            console.log("‚úÖ Model updated and saved successfully!");
        } catch (err) {
            console.error("‚ùå Training error:", err);
        } finally {
            // üî¥ ÿ™ÿ≠ÿ±Ÿäÿ± ÿßŸÑÿ∞ÿßŸÉÿ±ÿ© ŸäÿØŸàŸäŸãÿß
            tensors.inputTensor.dispose();
            tensors.actualTensor.dispose();
        }
    }
}





// ÿØÿßŸÑÿ© ŸÑÿ∑ŸÑÿ® ÿßŸÑŸÖÿØÿÆŸÑÿßÿ™ ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
async function askUserForInputs() {
    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });

    // ÿØÿßŸÑÿ© ŸÑÿ∑ÿ±ÿ≠ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©
    function askQuestion(question) {
        return new Promise(resolve => rl.question(question, answer => resolve(parseFloat(answer) || 0)));
    }

    const questions = [
        `${chalk.blue("üìè")} ${chalk.bold("Enter construction area (square meters): ")}`,
        `${chalk.green("üè†")} ${chalk.bold("Enter building type (1: Residential, 2: Pump Station, 3: Bridge): ")}`,
        `${chalk.yellow("üè¢")} ${chalk.bold("Enter number of floors: ")}`,
        `${chalk.cyan("üìÖ")} ${chalk.bold("Enter permit duration (years): ")}`,
        `${chalk.magenta("üåä")} ${chalk.bold("Enter distance from waterway (m): ")}`,
        `${chalk.red("üõ†Ô∏è")} ${chalk.bold("Enter soil type (1: Rocky, 2: Clay, 3: Sandy): ")}`,
        `${chalk.white("üí∞")} ${chalk.bold("Enter material cost per m¬≤: ")}`,
        `${chalk.green("üìÜ")} ${chalk.bold("Enter application year: ")}`
    ];

    // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Promise ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑŸÖÿØÿÆŸÑÿßÿ™ ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    const inputs = [];
    for (const question of questions) {
        inputs.push(await askQuestion(question));
    }

    rl.close();
    return inputs;
}

// ÿØÿßŸÑÿ© ŸÑÿ∑ŸÑÿ® ÿßŸÑÿ™ŸÉŸÑŸÅÿ© ÿßŸÑŸÅÿπŸÑŸäÿ©
async function askForActualCost() {
    return new Promise(resolve => {
        const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
        rl.question(chalk.bold.yellow("üí∞ Please input the actual cost and save the record: "), answer => {
            rl.close();
            resolve(parseFloat(answer) || 0);
        });
    });
}

// ÿØÿßŸÑÿ© ŸÑÿ∑ÿ®ÿßÿπÿ© ÿßŸÑÿπŸÜŸàÿßŸÜ ŸÖÿπ ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ŸàÿßŸÑÿ™ÿßÿ±ŸäÿÆ
function printTitle() {
    console.clear();

    console.log(
        gradient.pastel.multiline(
            figlet.textSync("AI-MODEL", { 
                font: "Big",
                horizontalLayout: "full",
                verticalLayout: "default"
            })
        )
    );

    console.log(
        boxen(chalk.bold.white(" Welcome to the AI-Driven Permit Management System ‚Äì Empowering Smart Decisions with Artificial Intelligence!"), { 
            padding: 1,  
            margin: .5,  
            backgroundColor: "black",
            borderStyle: "bold", 
            borderColor: "cyan", 
            align: "center"
        })
    );

    // ÿ¨ŸÑÿ® ÿßŸÑŸàŸÇÿ™ ŸàÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ≠ÿßŸÑŸä
    const now = new Date();
    const formattedTime = now.toLocaleTimeString('en-GB'); // HH:mm:ss
    const formattedDate = now.toLocaleDateString('en-GB'); // DD/MM/YYYY
    const timeAndDate = ` ${formattedTime}  ${formattedDate}`;

    // ÿ¨ŸÑÿ® ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ŸÖŸÜ ÿßŸÑÿ£ÿ±ÿ¥ŸäŸÅ
    const archiveStats = getArchiveStats();
    let statsMessage = "";

    if (archiveStats) {
        const shortLabels = ["area", "floors", "duration", "distance", "cost", "year"]; // ÿ¥ŸÑŸÜÿß type Ÿà soil

const values = Object.values(archiveStats.maxValues);

// ÿ¥ŸäŸÑ type Ÿà soil ŸÖŸÜ ÿßŸÑŸÖÿµŸÅŸàŸÅÿ©
values.splice(1, 1); // remove type
values.splice(4, 1); // remove soil (ŸÉÿßŸÜÿ™ index 5ÿå ÿ®ÿπÿØ ÿßŸÑÿ≠ÿ∞ŸÅ ÿßŸÑÿ£ŸàŸÑ ÿ®ŸÇÿ™ 4)

statsMessage = `üìä Total Records: ${archiveStats.total} | ` +
    values.map((value, index) => `${shortLabels[index]}: ${value}`).join(" | ");
} else {
    statsMessage = "No files found in archive.";
}

    

    // ÿ∑ÿ®ÿßÿπÿ© ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿ®ÿ¨ÿßŸÜÿ® ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸàÿßŸÑŸàŸÇÿ™
    console.log(
        boxen(
            chalk.bold.yellow(`${statsMessage} | ${timeAndDate}`), {
                padding: .5,
                margin: 1,
                backgroundColor: "black",
                borderStyle: "bold",
                borderColor: "cyan",
                align: "center"
            }
        )
    );

    console.log(
        chalk.underline(
            gradient(['#FF4500', '#FFA500', '#FFFF00'])(" Designed by Ahmed Amer\n")
        )
    );
}

// ÿØÿßŸÑÿ© `getArchiveStats` ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™
function getArchiveStats() {
    try {
        const filePath = path.join(__dirname, "operations.xlsx");

        if (!fs.existsSync(filePath)) {
            console.warn("‚ö†Ô∏è Excel file not found:", filePath);
            return null;
        }

        const workbook = xlsx.readFile(filePath);
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        const data = xlsx.utils.sheet_to_json(sheet);

        const stats = {
            total: data.length,
            maxValues: {}  // ŸáŸÜÿß ŸÜÿ≠ŸÅÿ∏ ÿ£ÿπŸÑŸâ ÿßŸÑŸÇŸäŸÖ
        };

        // ŸÇÿßÿ¶ŸÖÿ© ŸÖÿÆÿ™ÿµÿ±ÿ© ÿ®ÿ£ÿ≥ŸÖÿßÿ° ÿßŸÑÿ£ÿπŸÖÿØÿ©
        const shortNames = {
            "Construction Area": "Area",
            "Building Type": "Type",
            "Number of Floors": "Floors",
            "Permit Duration": "Years",
            "Distance from Waterway": "Dist",
            "Soil Type": "Soil",
            "Material Cost": "Cost",
            "Application Year": "Year",
            "Actual Cost": "Actual"
        };

        // ŸÜÿ≠ÿ≥ÿ® ÿ£ÿπŸÑŸâ ŸÇŸäŸÖÿ© ŸÅŸä ŸÉŸÑ ÿπŸÖŸàÿØ ÿ±ŸÇŸÖŸä
        const keys = Object.keys(data[0] || {});
        keys.forEach(key => {
            if (typeof data[0][key] === 'number') {
                let max = data[0][key];
                data.forEach(row => {
                    if (typeof row[key] === 'number' && row[key] > max) {
                        max = row[key];
                    }
                });

                // ÿ≠ŸÅÿ∏ ÿßŸÑŸÇŸäŸÖÿ© ŸÖÿπ ÿßÿ≥ŸÖ ŸÖÿÆÿ™ÿµÿ±
                stats.maxValues[shortNames[key] || key] = max;
            }
        });

        return stats;

    } catch (error) {
        console.error("‚ùå Error reading archive stats:", error.message);
        return null;
    }
}



// ÿØŸÖÿ¨ ÿßŸÑŸÉŸàÿØŸäŸÜ ŸÖÿπŸãÿß: ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑŸàÿ∏ÿßÿ¶ŸÅ
(async () => {
    printTitle(); 

    
})();



async function generateChart(userInputs, permitFee) {
    const width = 700, height = 450;
    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');

    // ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÇŸäŸÖ ÿßŸÑÿ±ŸÇŸÖŸäÿ© ŸÑŸÜŸàÿπ ÿßŸÑŸÖÿ®ŸÜŸâ ÿ•ŸÑŸâ ŸÜÿµŸàÿµ Ÿàÿßÿ∂ÿ≠ÿ© ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ©
    const buildingTypes = ["ÿ≥ŸÉŸÜ", "ŸÖÿ≠ÿ∑ÿ©", "ŸÉŸàÿ®ÿ±Ÿä"];
    const buildingType = buildingTypes[userInputs[1] - 1] || "ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ";

    // ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÇŸäŸÖ ÿßŸÑÿ±ŸÇŸÖŸäÿ© ŸÑŸÜŸàÿπ ÿßŸÑÿ™ÿ±ÿ®ÿ© ÿ•ŸÑŸâ ŸÜÿµŸàÿµ Ÿàÿßÿ∂ÿ≠ÿ© ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ©
    const soilTypes = ["ÿ∑ŸäŸÜŸäÿ©", "ÿ±ŸÖŸÑŸäÿ©", "ÿ≤ŸÑÿ∑Ÿäÿ©", "ÿµÿÆÿ±Ÿäÿ©"];
    const soilType = soilTypes[userInputs[5] - 1] || "ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ";

    // ÿ≥ŸÜÿ© ÿßŸÑÿ™ÿ±ÿÆŸäÿµ (ŸÑÿß ÿ™Ÿèÿπÿ±ÿ∂ ŸÉŸÇŸäŸÖÿ© ŸÉÿ®Ÿäÿ±ÿ©)
    const permitYear = userInputs[7];

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: [
                'üìè ÿßŸÑŸÖÿ≥ÿßÿ≠ÿ© (ŸÖ¬≤)', 
                'üè† ŸÜŸàÿπ ÿßŸÑŸÖÿ®ŸÜŸâ', 
                'üè¢ ÿπÿØÿØ ÿßŸÑÿ∑Ÿàÿßÿ®ŸÇ', 
                'üìÖ ÿßŸÑŸÖÿØÿ© (ÿ≥ŸÜŸàÿßÿ™)', 
                'üåä ÿßŸÑŸÖÿ≥ÿßŸÅÿ© (ŸÖ)', 
                'üõ†Ô∏è ŸÜŸàÿπ ÿßŸÑÿ™ÿ±ÿ®ÿ©', 
                'üí∞ ÿ™ŸÉŸÑŸÅÿ© ÿßŸÑŸÖŸàÿßÿØ (ŸÑŸÑŸÖÿ™ÿ±¬≤)'
            ],
            datasets: [{
                label: 'ŸÖÿπÿßŸäŸäÿ± ÿßŸÑÿ™ÿ±ÿÆŸäÿµ',
                data: [
                    userInputs[0], 
                    1, // ÿ™ŸÖÿ´ŸäŸÑ ŸÜŸàÿπ ÿßŸÑŸÖÿ®ŸÜŸâ ÿ®ÿ±ŸÇŸÖ ÿµÿ∫Ÿäÿ± ÿ≠ÿ™Ÿâ ŸÑÿß Ÿäÿ§ÿ´ÿ± ÿπŸÑŸâ ÿßŸÑÿßÿ±ÿ™ŸÅÿßÿπ
                    userInputs[2], 
                    userInputs[3], 
                    userInputs[4], 
                    1, // ÿ™ŸÖÿ´ŸäŸÑ ŸÜŸàÿπ ÿßŸÑÿ™ÿ±ÿ®ÿ© ÿ®ÿ±ŸÇŸÖ ÿµÿ∫Ÿäÿ± 
                    userInputs[6] 
                ],
                backgroundColor: ['#36A2EB', '#FFCE56', '#4CAF50', '#FF6384', '#8E44AD', '#FFC300', '#C70039']
            }]
        },
        options: {
            responsive: false,
            plugins: {
                title: {
                    display: true,
                    text: [
                        'üåä ÿßŸÑÿ™ÿ±ÿÆŸäÿµ ÿ®ÿ•ŸÇÿßŸÖÿ© ÿ£ÿπŸÖÿßŸÑ ÿÆÿßÿµÿ© ÿØÿßÿÆŸÑ ÿßŸÑÿ£ŸÖŸÑÿßŸÉ ÿßŸÑÿπÿßŸÖÿ© ÿ∞ÿßÿ™ ÿßŸÑÿµŸÑÿ© ÿ®ÿßŸÑŸÖŸàÿßÿ±ÿØ ÿßŸÑŸÖÿßÿ¶Ÿäÿ© ŸàÿßŸÑÿ±Ÿä üåä',
                        `üìä ÿßŸÑŸÖÿØÿÆŸÑÿßÿ™: ŸÖÿ≥ÿßÿ≠ÿ© ${userInputs[0]}ŸÖ¬≤ÿå ŸÜŸàÿπ ${buildingType}, ÿ∑Ÿàÿßÿ®ŸÇ ${userInputs[2]}, ŸÖÿØÿ© ${userInputs[3]} ÿ≥ŸÜŸàÿßÿ™ÿå ŸÖÿ≥ÿßŸÅÿ© ${userInputs[4]}ŸÖ`,
                        `üõ†Ô∏è ŸÜŸàÿπ ÿßŸÑÿ™ÿ±ÿ®ÿ©: ${soilType} - üí∞ ÿ™ŸÉŸÑŸÅÿ© ÿßŸÑŸÖŸàÿßÿØ: ${userInputs[6]} ÿ¨.ŸÖ ŸÑŸÑŸÖÿ™ÿ±¬≤ - üìÜ ÿ≥ŸÜÿ© ÿßŸÑÿ™ÿ±ÿÆŸäÿµ: ${permitYear}`,
                      `üí∞ ÿßŸÑÿ™ŸÉŸÑŸÅÿ© ÿßŸÑŸÖŸÇÿØÿ±ÿ© ŸÑŸÑÿ™ÿ±ÿÆŸäÿµ: $${permitFee.toFixed(2)} üí∞`

                    ],
                    font: { 
                        size: 19,
                        weight: 'bold',
                        family: 'Arial'
                    },
                    color: 'white',
                    padding: { top: 15, bottom: 15 }
                },
                legend: { display: false },
                tooltip: { enabled: true },
                datalabels: {
                    anchor: 'end',
                    align: 'top',
                    color: 'white',
                    font: { size: 16, weight: 'bold' },
                    formatter: function(value, context) {
                        if (context.dataIndex === 1 || context.dataIndex === 5) {
                            return ""; // ÿπÿØŸÖ ÿπÿ±ÿ∂ ÿßŸÑŸÇŸäŸÖ ÿßŸÑÿÆÿßÿµÿ© ÿ®ŸÜŸàÿπ ÿßŸÑŸÖÿ®ŸÜŸâ ŸàÿßŸÑÿ™ÿ±ÿ®ÿ©
                        }
                        return `${Math.round(value).toLocaleString()} ÿ¨.ŸÖ`;
                    }
                }
            },
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'üìè ŸÖÿπÿßŸäŸäÿ± ÿßŸÑÿ®ŸÜÿßÿ°',
                        color: 'white',
                        font: { size: 18, weight: 'bold' }
                    },
                    ticks: { color: 'white', font: { weight: 'bold' } },
                    grid: { color: 'rgba(255, 255, 255, 0.2)' }
                },
                y: {
                    title: {
                        display: true,
                        text: 'üìä ÿßŸÑŸÇŸäŸÖ',
                        color: 'white',
                        font: { size: 18, weight: 'bold' }
                    },
                    ticks: { 
                        color: 'white',
                        font: { weight: 'bold' },
                        beginAtZero: true,
                        callback: function(value) {
                            return `${Math.round(value).toLocaleString()} ÿ¨.ŸÖ`;
                        }
                    },
                    grid: { color: 'rgba(255, 255, 255, 0.2)' }
                }
            },
            barThickness: 50 // üî• ÿ≤ŸäÿßÿØÿ© ÿ≥ŸÖÿßŸÉÿ© ÿßŸÑÿ£ÿπŸÖÿØÿ©
        }
    });

    // ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿ±ÿ≥ŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸä ÿ•ŸÑŸâ ÿµŸàÿ±ÿ© ÿ®ÿµŸäÿ∫ÿ© PNG
    const buffer = canvas.toBuffer('image/png');

    // ÿ≠ŸÅÿ∏ ÿßŸÑÿµŸàÿ±ÿ© ŸÉŸÖŸÑŸÅ ŸÖÿ≠ŸÑŸä
    await fs.promises.writeFile(CHART_PATH, buffer);
    console.log(`üìä Chart saved as ${CHART_PATH}`);

    // ŸÅÿ™ÿ≠ ÿßŸÑÿµŸàÿ±ÿ© ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß ÿ®ÿπÿØ ÿ≠ŸÅÿ∏Ÿáÿß
    exec(`start ${CHART_PATH}`, (err) => {
        if (err) console.error("‚ö†Ô∏è ŸÅÿ¥ŸÑ ŸÅŸä ŸÅÿ™ÿ≠ ÿßŸÑÿ±ÿ≥ŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸä:", err);
    });
}






async function logToExcel(userInputs, priceUSD, priceEGP) {
    try {
        let workbook;
        try {
            // üìÇ ŸÖÿ≠ÿßŸàŸÑÿ© ŸÇÿ±ÿßÿ°ÿ© ŸÖŸÑŸÅ Excel ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖŸàÿ¨ŸàÿØŸãÿß
            const fileBuffer = await fs.promises.readFile(EXCEL_PATH);
            workbook = XLSX.read(fileBuffer, { type: "buffer" });
        } catch {
            // üìÑ ÿ•ŸÜÿ¥ÿßÿ° ŸÖŸÑŸÅ ÿ¨ÿØŸäÿØ ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸÖŸàÿ¨ŸàÿØŸãÿß
            workbook = XLSX.utils.book_new();
            const sheet = XLSX.utils.aoa_to_sheet([
                [
                    "üìÜ Date & Time",
    "üìè  construction area (square meters)",
    "üè†  building type (1: Residential, 2: Pump Station, 3: Bridge)",
    "üè¢  number of floors",
    "üìÖ  permit duration (years)",
    "üåä  distance from waterway (m)",
    "üõ†Ô∏è  soil type (1: Rocky, 2: Clay, 3: Sandy)",
    "üí∞  material cost per m¬≤",
    "üìÜ  application year",
    "üí∞  house price (USD)",
    "üí∞  house price (EGP)"
                ]
            ]);
            XLSX.utils.book_append_sheet(workbook, sheet, "PermitData");
        }

        // üìú ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ Ÿàÿ±ŸÇÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
        const sheet = workbook.Sheets["PermitData"];
        
        // üìù ÿ™ÿ¨ŸáŸäÿ≤ ÿµŸÅ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ¨ÿØŸäÿØ
        const newRow = [
            new Date().toISOString().replace("T", " ").slice(0, 19), // üïí ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿ®ÿµŸäÿ∫ÿ© ÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ© YYYY-MM-DD HH:MM:SS
            ...userInputs, // üìå ÿßŸÑŸÇŸäŸÖ ÿßŸÑŸÖÿØÿÆŸÑÿ©
            priceUSD.toFixed(2), // üí≤ ÿßŸÑÿ≥ÿπÿ± ÿ®ÿßŸÑÿØŸàŸÑÿßÿ±
            priceEGP.toFixed(2)   // üí∞ ÿßŸÑÿ≥ÿπÿ± ÿ®ÿßŸÑÿ¨ŸÜŸäŸá ÿßŸÑŸÖÿµÿ±Ÿä
        ];

        // üìå ÿ™ÿ≠ŸàŸäŸÑ Ÿàÿ±ŸÇÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ•ŸÑŸâ ŸÖÿµŸÅŸàŸÅÿ© JSON ŸÑÿ™ÿ≠ÿØŸäÿ´Ÿáÿß
        const sheetData = XLSX.utils.sheet_to_json(sheet, { header: 1 });

        // ‚ûï ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿµŸÅ ÿßŸÑÿ¨ÿØŸäÿØ ÿ•ŸÑŸâ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
        sheetData.push(newRow);

        // üîÑ ÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ•ŸÑŸâ Ÿàÿ±ŸÇÿ© ÿπŸÖŸÑ
        const newSheet = XLSX.utils.aoa_to_sheet(sheetData);
        workbook.Sheets["PermitData"] = newSheet;

        // üíæ ÿ≠ŸÅÿ∏ ÿßŸÑŸÖŸÑŸÅ ÿ®ÿπÿØ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´
        const excelBuffer = XLSX.write(workbook, { bookType: "xlsx", type: "buffer" });
        await fs.promises.writeFile(EXCEL_PATH, excelBuffer);

        console.log("‚úÖ Operation logged in Excel successfully!"); // ‚úÖ ÿ™ÿ£ŸÉŸäÿØ ŸÜÿ¨ÿßÿ≠ ÿßŸÑÿπŸÖŸÑŸäÿ©
    } catch (error) {
        console.error("‚ö†Ô∏è Error logging to Excel:", error);
    }
}





async function runModel() {
    let model, normalizationParams;
    const USD_TO_EGP = 50.67; // ÿßÿ≥ÿ™ÿ®ÿØŸÑ ÿ®ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑŸÅÿπŸÑŸäÿ© ŸÑÿ≥ÿπÿ± ÿßŸÑÿµÿ±ŸÅ

    if (modelExists()) {
        console.log("üì¶ Found saved model. Loading...");
        ({ model, normalizationParams } = await loadModel());
    } else {
        console.log("üèóÔ∏è No saved model found. Training a new model...");
        model = createModel();
        normalizationParams = await trainModel(model);
    }

    if (!normalizationParams) {
        console.error("‚ùå Error: Normalization parameters are missing! Cannot proceed.");
        return;
    }

    const userInput = await askUserForInputs();
    if (userInput.includes(undefined) || userInput.includes(NaN)) {
        console.error("‚ùå Error: Invalid user input.");
        return;
    }

    console.log(`üî¢ Inputs received: ${userInput.join(", ")}`);

    const normalizedInput = normalizeData(userInput, normalizationParams.minInput, normalizationParams.maxInput);
    if (normalizedInput.includes(NaN)) {
        console.error("‚ùå Error: Normalized data contains NaN.");
        return;
    }

    const inputTensor = tf.tensor2d([normalizedInput]);
    const predictedTensor = model.predict(inputTensor);
    const predictedCostNormalized = predictedTensor.dataSync()[0];

    if (isNaN(predictedCostNormalized)) {
        console.error("‚ùå Error: Predicted cost is NaN.");
        return;
    }

    const predictedCost = predictedCostNormalized * (normalizationParams.maxOutput - normalizationParams.minOutput) + normalizationParams.minOutput;
    const predictedUSD = predictedCost / USD_TO_EGP;

    console.log(`üîÆ Predicted permit cost: $${predictedUSD.toFixed(2)} USD (${predictedCost.toFixed(2)} EGP)`);

    // ÿ•ÿ∂ÿßŸÅÿ© ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÖÿÆÿ∑ÿ∑
    await generateChart(userInput, predictedUSD, predictedCost);
    
    // ÿ•ÿ∂ÿßŸÅÿ© ÿ≠ŸÅÿ∏ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÅŸä ŸÖŸÑŸÅ ÿ•ŸÉÿ≥ŸÑ
    await logToExcel(userInput, predictedUSD, predictedCost);
    
    const actualCost = await askForActualCost();
    await reinforcementLearning(model, userInput, parseFloat(actualCost), normalizationParams);
}

runModel().catch(console.error);
